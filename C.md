# C语言



## C语言基本类型

| 类型 | 长度 |
| :-: | :-: |
| int | 4 |
| char | 1 |
| float | 4 |
| double | 8 |
| long | 8 |
| short | 2 |
| signed | 4 |
| unsigned | 4 | 
| void | 1 |

## java基本数据类型和c语言的一些区别

> **注意：**  c99标准规定：long类型的规定，不小于整形

- java中`char`类型的长度为**2**个字节，c语言中的长度为**1**个字节
- java中`long`类型的长度为**8**个字节，c语言中的长度为**4**个字节
- c语言中没有`byte`
- c语言中`boolean`类型，0表示`false`，非零表示`true`
- `unsigned`表示无符号，为正数，长度在**0～255**，**-2^7 ~2^7 -1**
- `signed`表示有符号，为负数，长度在**-128～127**，**0~2^8 -1**
- `void`表示无类型，代表任意类型

## 输出函数

> **注意：** 
>
> 1. c语言默认取小数点后6位
> 
> 2. 对应的类型用对应的占位符，否则精度丢失
> 
> 3. 在c语言中，默认保留小数点后六位。要想保留对应的位数，就需在百分号后面加上`.数字`
> 
> 4. c语言中数组的括号不能写在左边



| 类型 | 占位符 |
| :-: | :-: |
| int | %d |
| long int | %ld |
| char | %c |
| float | %f |
| 无符号数 | %u |
| 短整型 | %hd |
| double | %lf |
| 十六进制输出,int或者long int或者short int | %x |
| 八进制输出 | %o |
| 字符串 | %s |

## 输入函数

```
scanf("占位符",内存地址)
```
> **注意：**  
> 
> 1. c语言没有字符串，可以用char数组表示
> 
> 2. 数组的结束表示：\0
> 
> 3. 数组是一块连续的内存空间
> 

## 指针

>**注意：**  
>  **指针就是内存地址，内存地址就是指针**
> 
> 1. 指针就是地址，地址就是指针
> 2. 指针就是内存单元的编号
> 3. 指针变量就是存放地址的变量
> 4. 指针和指针变量是两个不同的概念
> 

* 指针的重要性
    1. 直接访问硬件(opengl显卡绘图)
    2. 快速传递数据(指针表示地址)
    3. 返回一个以上的值(返回一个数组或者结构体的指针)
    4. 表示复杂的数据结构(结构体)
    5. 方便处理字符串
    6. 指针有助于理解面向对象

* *的三种含义
    1. 数学运算符： `3 * 5 `;
    2. 定义指针变量: `int *p`;
    3. 指针运算符(取值): *p `取p的内容(地址)在内存中的值`；


* 小结：(通过被调函数修改主调函数普通变量的值)
    1. 实参必须是普通变量的地址
    2. 形参必须是指针变量
    3. 被调函数中通过修改 *形参名的方式修改主调函数相关变量的值

    
## 数组的简介
> **注意：**  
> 
> 1. 数组是一块连续的内存空间
> 2. 数组的首元素的首地址和数组的地址相同
> 


- 取数组地址值的规律
    1. iArray+下标
    2. &(iArray[下标])
    
- 数组在移动时，会根据类型移动指定的字节
    1. int类型的数组，在+1时，会跳过4个字节
    2. char类型的数组，在+1时，会跳过1个字节

## 内存分配
> **注意：** 
> 1. **静态内存**是程序编译执行后系统自动分配，由系统自动释放，静态内存时栈分配的
> 2. **动态内存**是开发者手动分配的，是堆分配的
> 

1. 从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。
2. 在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
3. 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。

### 内存申请方式

* **栈**

由系统自动分配，例如，申明一个局部变量int b;系统自动在栈中为b开辟空间，例如在调用函数时，需要保存的变量，最明显的是在递归调用时，要系统自动分配一个栈的空间，后进先出的，而后又由系统释放这个空间。

* **堆**

需要程序员自己申请，并指明大小，在c中用malloc函数,如

```
char* p1 =(char*)malloc(10);    //14byte
```
注意：p1本身是在栈中的。

### 申请后系统的响应

* **栈**

只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。

* **堆**

首先应该知道操作系统中有一个记录空闲内存地址的链表，当系统收到程序的申请时，后遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多少系统，会在这块内存空间中的首地址处记录此次分配到大小，这样，代码中的delete语句才能正常的释放本内存空间。另外，由于找到的堆节点大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。

### 申请效率的比较

* **栈**

由系统自动分配，速度较快。但程序员无法控制。

* **堆**

由malloc／new分配的内存，一般速度比较慢，而且容易产生内存碎片，不过用起来比较方便。

### 堆和栈中的存储内容

* **栈**

在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数c编译器中，参数是由右向左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。
当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。

* **堆**

一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容由程序员安排。

### 内存的回收

栈上分配到内存，编译器会自动收回；堆上分配的内存，要通过free来显式地回收，否则会造成内存泄漏。

**堆和栈的区别**可以用如下比喻来形容：

* 使用**栈**就像我们去饭馆吃饭，只管点菜（发出申请）、付钱和吃（使用），吃饱了就走，不必理会切菜、洗菜等准备工作和洗碗、刷锅等扫尾工作，他的好处是快捷，但是自由度小。
* 使用**堆**好比自己动手做喜欢吃的菜肴，比较麻烦，但是比较符合自己的口味，而且自由度大


## 函数指针
```
int (*af)(int x,int y);
```
## Unition联合体

 所有字段共用一块内存空间
 应用场景：各个类型之间方便互相转换
 
## 枚举
1. 值是递增的
2. 默认值从0开始 


